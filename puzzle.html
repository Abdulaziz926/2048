<!doctype html>
<html lang="uz">

<head>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width,initial-scale=1" />
	<title>2048</title>
	<link rel="icon" href="ar_logo_circle.png">
	<style>
		:root {
			--bg: #faf8ef;
			--board: #bbada0;
			--tile-bg: #cdc1b4;
			--text-dark: #776e65;
			--score-bg: #eee4da;
			--accent: #f59563;
		}

		* {
			box-sizing: border-box
		}

		html,
		body {
			height: 100%;
			margin: 0;
			font-family: "Clear Sans", "Helvetica Neue", Arial, sans-serif;
			background: var(--bg);
			color: var(--text-dark)
		}

		.wrap {
			max-width: 520px;
			margin: 28px auto;
			padding: 16px
		}

		header {
			display: flex;
			align-items: center;
			justify-content: space-between;
			margin-bottom: 12px
		}

		h1 {
			font-size: 40px;
			margin: 0;
			letter-spacing: -1px;
			color: #776e65
		}

		.scores {
			display: flex;
			gap: 10px
		}

		.score-box {
			background: var(--score-bg);
			padding: 8px 12px;
			border-radius: 4px;
			text-align: center;
			min-width: 84px
		}

		.score-box .label {
			font-size: 12px;
			color: #9e948a
		}

		.score-box .value {
			font-weight: 700;
			font-size: 18px
		}

		.controls {
			display: flex;
			gap: 8px;
			align-items: center
		}

		.btn {
			background: #8f7a66;
			color: #fff;
			padding: 8px 12px;
			border-radius: 4px;
			border: none;
			cursor: pointer;
			font-weight: 700
		}

		.btn.ghost {
			background: transparent;
			border: 1px solid rgba(0, 0, 0, 0.08);
			color: var(--text-dark);
			font-weight: 600
		}

		/* board */
		.game {
			background: linear-gradient(#bbada0, #b29a8f);
			padding: 18px;
			border-radius: 6px;
			position: relative
		}

		.grid {
			width: 100%;
			height: 100%;
			display: grid;
			grid-template-columns: repeat(4, 1fr);
			grid-gap: 12px;
		}

		.cell {
			background: rgba(238, 228, 218, 0.35);
			border-radius: 4px;
			padding-top: 100%;
			/* square responsive */
			position: relative;
			overflow: visible;
		}

		.cell>.inner {
			position: absolute;
			inset: 0;
			display: flex;
			align-items: center;
			justify-content: center
		}

		/* tile layer */
		.tile-container {
			position: absolute;
			inset: 18px;
			pointer-events: none
		}

		.tile {
			position: absolute;
			border-radius: 4px;
			display: flex;
			align-items: center;
			justify-content: center;
			font-weight: 700;
			transition: transform 120ms ease-in-out, top 120ms linear, left 120ms linear;
			will-change: transform, top, left;
			box-shadow: 0 3px 0 rgba(0, 0, 0, 0.1);
		}

		.tile .num {
			display: block;
			font-size: 24px
		}

		/* tile colors (close to official) */
		.tile.tile-2 {
			background: #eee4da;
			color: #776e65
		}

		.tile.tile-4 {
			background: #ede0c8;
			color: #776e65
		}

		.tile.tile-8 {
			background: #f2b179;
			color: #f9f6f2
		}

		.tile.tile-16 {
			background: #f59563;
			color: #f9f6f2
		}

		.tile.tile-32 {
			background: #f67c5f;
			color: #f9f6f2
		}

		.tile.tile-64 {
			background: #f65e3b;
			color: #f9f6f2
		}

		.tile.tile-128 {
			background: #edcf72;
			color: #f9f6f2;
			font-size: 20px
		}

		.tile.tile-256 {
			background: #edcc61;
			color: #f9f6f2;
			font-size: 20px
		}

		.tile.tile-512 {
			background: #edc850;
			color: #f9f6f2;
			font-size: 20px
		}

		.tile.tile-1024 {
			background: #edc53f;
			color: #f9f6f2;
			font-size: 18px
		}

		.tile.tile-2048 {
			background: #edc22e;
			color: #f9f6f2;
			font-size: 18px
		}

		.tile.big {
			font-size: 16px;
			padding: 10px
		}

		/* overlay for win/lose */
		.overlay {
			position: absolute;
			inset: 0;
			background: rgba(238, 228, 218, 0.6);
			display: flex;
			align-items: center;
			justify-content: center;
			border-radius: 6px;
			z-index: 50;
			flex-direction: column;
			backdrop-filter: blur(2px)
		}

		.overlay h2 {
			font-size: 36px;
			margin: 0;
			color: #776e65
		}

		.overlay p {
			margin: 8px 0 16px;
			color: #776e65
		}

		/* footer / attribution */
		.attribution {
			margin-top: 12px;
			text-align: center;
			color: #9e948a;
			font-size: 13px
		}

		.attribution a {
			color: inherit;
			text-decoration: none;
			font-weight: 700
		}

		/* responsive */
		@media (max-width:480px) {
			h1 {
				font-size: 32px
			}

			.btn {
				padding: 6px 8px
			}
		}
	</style>
</head>

<body>
	<div class="wrap">
		<header>
			<div>
				<h1>2048</h1>
				<!-- inglizcha satr olib tashlandi -->
			</div>
			<div class="controls">
				<div class="scores">
					<div class="score-box">
						<div class="label">SCORE</div>
						<div id="score" class="value">0</div>
					</div>
					<div class="score-box">
						<div class="label">BEST</div>
						<div id="best" class="value">0</div>
					</div>
				</div>
				<button id="newGame" class="btn">New Game</button>
			</div>
		</header>

		<div class="game" id="game">
			<div class="grid" id="grid">
				<!-- 16 cells -->
				<div class="cell">
					<div class="inner"></div>
				</div>
				<div class="cell">
					<div class="inner"></div>
				</div>
				<div class="cell">
					<div class="inner"></div>
				</div>
				<div class="cell">
					<div class="inner"></div>
				</div>
				<div class="cell">
					<div class="inner"></div>
				</div>
				<div class="cell">
					<div class="inner"></div>
				</div>
				<div class="cell">
					<div class="inner"></div>
				</div>
				<div class="cell">
					<div class="inner"></div>
				</div>
				<div class="cell">
					<div class="inner"></div>
				</div>
				<div class="cell">
					<div class="inner"></div>
				</div>
				<div class="cell">
					<div class="inner"></div>
				</div>
				<div class="cell">
					<div class="inner"></div>
				</div>
				<div class="cell">
					<div class="inner"></div>
				</div>
				<div class="cell">
					<div class="inner"></div>
				</div>
				<div class="cell">
					<div class="inner"></div>
				</div>
				<div class="cell">
					<div class="inner"></div>
				</div>
			</div>

			<div class="tile-container" id="tile-container"></div>

			<!-- overlay -->
			<div id="overlay" class="overlay" style="display:none">
				<h2 id="overlay-title">You win!</h2>
				<p id="overlay-text">You reached 2048.</p>
				<div style="display:flex;gap:8px">
					<button id="keepPlaying" class="btn">Keep going</button>
					<button id="retry" class="btn ghost">Try again</button>
				</div>
			</div>
		</div>

		<!-- Attribution: GitHub user va muallif -->
		<div class="attribution">
			<a href="https://github.com/Abdulaziz926" target="_blank" rel="noopener noreferrer">by Rakhmanov Abdulaziz
		</div>

	</div>

	<script>
		/*
			Simple 2048 clone (official-like)
			Features:
			 - 4x4 grid
			 - spawn 2 or 4
			 - keyboard arrows and swipe
			 - animations via absolute-positioned tiles
			 - score and best stored in localStorage
		*/

		(function () {
			const size = 4
			const tileContainer = document.getElementById('tile-container')
			const scoreEl = document.getElementById('score')
			const bestEl = document.getElementById('best')
			const newGameBtn = document.getElementById('newGame')
			const overlay = document.getElementById('overlay')
			const overlayTitle = document.getElementById('overlay-title')
			const overlayText = document.getElementById('overlay-text')
			const keepPlayingBtn = document.getElementById('keepPlaying')
			const retryBtn = document.getElementById('retry')
			let score = 0
			let best = parseInt(localStorage.getItem('2048-best') || '0', 10)
			bestEl.textContent = best
			let grid = [] // 2D array of numbers, 0 means empty
			let tiles = [] // array of tile DOM models for animation
			let hasWon = false
			let animDuration = 120 // ms (matches CSS)

			// responsive cell sizing
			function cellSize() {
				const board = document.getElementById('grid')
				const style = getComputedStyle(board)
				const gap = parseInt(style.gridRowGap) || 12
				const width = board.clientWidth
				const cell = Math.floor((width - gap * (size - 1)) / size)
				return cell
			}

			function posToPixel(row, col) {
				const cell = cellSize()
				const gap = 12
				const top = row * (cell + gap)
				const left = col * (cell + gap)
				return { top, left, width: cell, height: cell }
			}

			function createTileElement(value, row, col) {
				const el = document.createElement('div')
				el.className = 'tile tile-' + value
				el.style.width = posToPixel(row, col).width + 'px'
				el.style.height = posToPixel(row, col).height + 'px'
				el.style.top = posToPixel(row, col).top + 'px'
				el.style.left = posToPixel(row, col).left + 'px'
				el.innerHTML = '<div class="num">' + value + '</div>'
				return el
			}

			function clearTilesDOM() {
				tileContainer.innerHTML = ''
				tiles = []
			}

			function spawnRandom() {
				const empties = []
				for (let r = 0; r < size; r++) for (let c = 0; c < size; c++) if (grid[r][c] === 0) empties.push([r, c])
				if (empties.length === 0) return false
				const [r, c] = empties[Math.floor(Math.random() * empties.length)]
				// spawn 2 with 90%, 4 with 10% (classic)
				const val = Math.random() < 0.9 ? 2 : 4
				grid[r][c] = val
				// add tile DOM with appear animation (scale)
				const el = createTileElement(val, r, c)
				el.style.transform = 'scale(0)'
				tileContainer.appendChild(el)
				requestAnimationFrame(() => el.style.transform = 'scale(1)')
				tiles.push({ el, row: r, col: c, value: val, merged: false, from: null })
				return true
			}

			function initGrid() {
				grid = Array.from({ length: size }, () => Array.from({ length: size }, () => 0))
				clearTilesDOM()
				score = 0; scoreEl.textContent = score
				hasWon = false
				overlay.style.display = 'none'
				// spawn two tiles
				spawnRandom()
				spawnRandom()
				renderAllTiles(true)
			}

			function renderAllTiles(instant = false) {
				// remove all and recreate from grid (simpler)
				tileContainer.innerHTML = ''
				tiles = []
				for (let r = 0; r < size; r++) {
					for (let c = 0; c < size; c++) {
						const v = grid[r][c]
						if (v !== 0) {
							const el = createTileElement(v, r, c)
							if (!instant) {
								el.style.transform = 'scale(0.8)'
								el.style.opacity = '0.95'
								setTimeout(() => el.style.transform = 'scale(1)', 20)
							}
							tileContainer.appendChild(el)
							tiles.push({ el, row: r, col: c, value: v })
						}
					}
				}
			}

			function updateScore(points) {
				score += points
				scoreEl.textContent = score
				if (score > best) {
					best = score
					bestEl.textContent = best
					localStorage.setItem('2048-best', String(best))
				}
			}

			// movement helpers
			function move(direction) {
				// direction: 'left','right','up','down'
				// return true if any tile moved or merged
				let moved = false
				const dir = direction
				// We'll process rows/cols in order depending on direction
				const mergedPositions = []
				const get = (r, c) => grid[r][c]
				const set = (r, c, val) => { grid[r][c] = val }
				const inRange = (r, c) => r >= 0 && r < size && c >= 0 && c < size
				// function to compress a line and merge
				function processLine(cells) {
					// cells: array of {r,c}
					const vals = cells.map(({ r, c }) => get(r, c)).filter(v => v !== 0)
					for (let i = 0; i < vals.length - 1; i++) {
						if (vals[i] === vals[i + 1]) {
							vals[i] = vals[i] * 2
							updateScore(vals[i])
							vals.splice(i + 1, 1)
						}
					}
					// fill back
					let changed = false
					for (let i = 0; i < cells.length; i++) {
						const newVal = vals[i] || 0
						const { r, c } = cells[i]
						if (get(r, c) !== newVal) {
							set(r, c, newVal)
							changed = true
						}
					}
					return changed
				}

				if (dir === 'left' || dir === 'right') {
					for (let r = 0; r < size; r++) {
						const cells = []
						if (dir === 'left') {
							for (let c = 0; c < size; c++) cells.push({ r, c })
						} else {
							for (let c = size - 1; c >= 0; c--) cells.push({ r, c })
						}
						const changed = processLine(cells)
						if (changed) moved = true
					}
				} else {
					for (let c = 0; c < size; c++) {
						const cells = []
						if (dir === 'up') {
							for (let r = 0; r < size; r++) cells.push({ r, c })
						} else {
							for (let r = size - 1; r >= 0; r--) cells.push({ r, c })
						}
						const changed = processLine(cells)
						if (changed) moved = true
					}
				}

				if (moved) {
					// animate: re-render tiles with slight delay to show movement
					renderAllTiles()
					setTimeout(() => {
						spawnRandom()
						renderAllTiles()
						checkGameState()
					}, animDuration + 10)
				}
				return moved
			}

			function checkGameState() {
				// check win (tile 2048) and lose (no moves)
				let hasEmpty = false
				let canMove = false
				for (let r = 0; r < size; r++) {
					for (let c = 0; c < size; c++) {
						const v = grid[r][c]
						if (v === 0) hasEmpty = true
						if (v === 2048) hasWon = true
						// check neighbors for possible merge
						const neighbors = [[r + 1, c], [r - 1, c], [r, c + 1], [r, c - 1]]
						for (const [nr, nc] of neighbors) {
							if (nr >= 0 && nr < size && nc >= 0 && nc < size) {
								if (grid[nr][nc] === v) canMove = true
							}
						}
					}
				}
				if (hasWon) {
					overlayTitle.textContent = 'You win!'
					overlayText.textContent = 'You reached 2048.'
					overlay.style.display = 'flex'
				} else if (!hasEmpty && !canMove) {
					overlayTitle.textContent = 'Game over!'
					overlayText.textContent = 'No moves left.'
					overlay.style.display = 'flex'
				}
			}

			// keyboard events
			window.addEventListener('keydown', function (e) {
				let moved = false
				if (e.key === 'ArrowLeft') { moved = move('left') }
				else if (e.key === 'ArrowUp') { moved = move('up') }
				else if (e.key === 'ArrowRight') { moved = move('right') }
				else if (e.key === 'ArrowDown') { moved = move('down') }
				else return
				if (moved) e.preventDefault()
			})

			// swipe handling
			let touchStart = null
			const minSwipe = 30
			const gameEl = document.getElementById('game')
			gameEl.addEventListener('touchstart', function (e) {
				if (e.touches.length > 1) return
				const t = e.touches[0]
				touchStart = { x: t.clientX, y: t.clientY }
			}, { passive: true })
			gameEl.addEventListener('touchend', function (e) {
				if (!touchStart) return
				const t = e.changedTouches[0]
				const dx = t.clientX - touchStart.x
				const dy = t.clientY - touchStart.y
				if (Math.abs(dx) < minSwipe && Math.abs(dy) < minSwipe) { touchStart = null; return }
				if (Math.abs(dx) > Math.abs(dy)) {
					if (dx > 0) move('right'); else move('left')
				} else {
					if (dy > 0) move('down'); else move('up')
				}
				touchStart = null
			})

			// new game
			newGameBtn.addEventListener('click', function () { initGrid() })

			keepPlayingBtn.addEventListener('click', function () {
				overlay.style.display = 'none'
				hasWon = false
			})
			retryBtn.addEventListener('click', function () {
				initGrid()
			})

			// resize: re-render sizes
			window.addEventListener('resize', function () {
				renderAllTiles(true)
			})

			// start
			initGrid()

		})();
	</script>
</body>

</html>